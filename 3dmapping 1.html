<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mapping ‚Äì Fixed Export & Controls (v23 avec preview mapping)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial;background:#0a0a0a;color:#fff;padding-top:72px}
    .top-bar{position:fixed;top:0;left:0;right:0;height:64px;background:#071018;display:flex;align-items:center;gap:12px;padding:10px 14px;z-index:1000}
    .btn{padding:8px 12px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#fff;cursor:pointer}
    .btn-danger{background:rgba(220,38,38,0.12);border-color:#dc2626;color:#fff}
    .select,.input{padding:6px;border-radius:6px;background:rgba(255,255,255,0.03);color:#fff;border:1px solid rgba(255,255,255,0.06)}
    .panel{position:fixed;left:12px;top:72px;background:rgba(10,10,10,0.95);padding:12px;border-radius:8px;width:460px;height:calc(100vh - 84px);overflow:auto;z-index:100}
    #main-viewport{position:fixed;top:72px;left:492px;right:20px;bottom:20px;background:#081018;border-radius:6px;overflow:hidden;display:flex;align-items:flex-start;justify-content:center}
    .preview-grid{position:absolute;bottom:12px;right:12px;display:grid;grid-template-columns:repeat(1,400px);gap:10px;z-index:30}
    .preview-screen{position:relative;border:2px solid rgba(255,255,255,0.1);border-radius:6px;overflow:hidden;background:#000}
    #miniLog{margin-top:8px;font-family:monospace;font-size:12px;color:#9ca3af;height:180px;overflow:auto;background:rgba(0,0,0,0.4);padding:8px;border-radius:6px}
    .list-item{display:flex;justify-content:space-between;align-items:center;padding:6px;border-radius:6px}
    .metrics input{width:80px;padding:6px;border-radius:6px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.06);color:#fff}
    .top-right-controls{margin-left:auto;display:flex;gap:8px;align-items:center}
    .small{padding:6px 8px;font-size:12px}
  </style>
</head>
<body>
  <div class="top-bar">
    <div style="font-weight:800;color:#0dd6b6">Mapping 3D ‚Äì v23 avec preview</div>
    <button class="btn" onclick="uploadContent()">üìÅ Load content</button>
    <label style="margin-left:8px">Resolution
      <select id="exportRes" class="select">
        <option value="preview">Preview</option>
        <option value="1080p">FullHD (1920√ó1080)</option>
        <option value="4k">4K (3840√ó2160)</option>
      </select>
    </label>
    <label style="display:flex;align-items:center;gap:6px">
      FPS <input id="exportFps" class="input small" value="30" style="width:56px;margin-left:6px"/>
    </label>
    <button id="btnPlay" class="btn" onclick="togglePlay()">‚ñ∂ Play</button>
    <label style="display:flex;align-items:center;gap:6px;margin-left:6px">
      <input id="autoRec" type="checkbox"/> Auto-record on play
    </label>
    <button id="recordBtn" class="btn btn-danger" onclick="toggleRecording()">üî¥ Record</button>
    <button class="btn" id="exportBtn" onclick="startExport()">‚¨áÔ∏è Export</button>
    <div class="top-right-controls">
      <label style="display:flex;align-items:center;gap:6px">
        Orientation:
        <select id="projOrient" class="select" title="Projector orientation (portrait / landscape)">
          <option value="portrait">Portrait (9:16)</option>
          <option value="landscape">Landscape (16:9)</option>
        </select>
      </label>
      <button class="btn small" id="btnTranslate" onclick="setTransformMode('translate')">Translate</button>
      <button class="btn small" id="btnRotate" onclick="setTransformMode('rotate')">Rotate</button>
      <button class="btn small" id="btnScale" onclick="setTransformMode('scale')">Scale</button>
      <button class="btn small" id="btnDeleteSelected" onclick="deleteSelected()">Delete</button>
    </div>
  </div>
  <div class="panel" id="controls">
    <h3 style="color:#0dd6b6;margin:0 0 6px 0">Scene & Export</h3>
    <div style="margin-top:6px">
      <label><input id="useProj" type="checkbox" checked/> Use projector</label>
    </div>
    <div style="margin-top:10px" class="transform-controls">
      <button id="addBox" class="btn">Add Box</button>
      <button id="addPlane" class="btn">Add Plane</button>
      <button id="addSphere" class="btn">Add Sphere</button>
    </div>
    <div style="margin-top:12px">
      <div style="font-weight:700;color:#0dd6b6;margin-bottom:6px">Scene contents</div>
      <div style="font-size:12px;color:#9aaabb;margin-bottom:6px">Objects</div>
      <div id="object-list" style="max-height:160px;overflow:auto"></div>
      <div style="height:8px"></div>
      <div style="font-size:12px;color:#9aaabb;margin-bottom:6px">Projector</div>
      <div id="projector-list"></div>
    </div>
    <div style="margin-top:12px" class="metrics">
      <div>Selected:</div>
      <input id="metric-name" readonly placeholder="None" />
      <div style="margin-top:8px">Pos (m) <input id="metric-x" /> <input id="metric-y" /> <input id="metric-z" /></div>
      <div style="margin-top:8px">Rot (deg) <input id="metric-rotx" /> <input id="metric-roty" /> <input id="metric-rotz" /></div>
      <div style="margin-top:8px"><button id="metric-apply" class="btn">Apply</button></div>
    </div>
    <div style="margin-top:12px">
      <div style="font-weight:700;color:#0dd6b6;margin-bottom:6px">Log</div>
      <div id="miniLog">mini-log...</div>
    </div>
  </div>
  <div id="main-viewport">
    <div class="preview-grid">
      <div class="preview-screen">
        <div style="position:absolute;left:6px;top:6px;background:rgba(13,148,136,0.9);padding:4px 8px;border-radius:6px;z-index:12;color:#fff;font-size:11px">
          Proj Output <button class="btn small" onclick="downloadLast('proj')" style="margin-left:4px;padding:2px 6px">DL</button>
        </div>
        <canvas id="preview1" style="width:400px;height:150px"></canvas>
      </div>
      <div class="preview-screen">
        <div style="position:absolute;left:6px;top:6px;background:rgba(220,38,38,0.9);padding:4px 8px;border-radius:6px;z-index:12;color:#fff;font-size:11px">
          Main View (mapping)
        </div>
        <canvas id="preview2" style="width:400px;height:150px"></canvas>
      </div>
    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
  <script>
  let scene, camera, renderer, cube, projectors = [], contentTexture = null, contentVideo = null;
  let wall = null;
  const dpr = window.devicePixelRatio || 1;
  const miniLogEl = () => document.getElementById('miniLog');
  function miniLog(msg){ console.log(msg); const el = miniLogEl(); el.textContent += (el.textContent ? '\n' : '') + msg; el.scrollTop = el.scrollHeight; }
  let orbit, transformControl;
  let selected = null;
  const interactiveObjects = [];
  const primitives = [];
  const projectionOverlays = new Map();
  let gridHelper = null, axesHelper = null;
  let defaultViewportSize = { w: 0, h: 0 };
  const defaultWhiteCanvas = document.createElement('canvas');
  defaultWhiteCanvas.width = defaultWhiteCanvas.height = 1;
  defaultWhiteCanvas.getContext('2d').fillStyle = '#ffffff';
  defaultWhiteCanvas.getContext('2d').fillRect(0,0,1,1);
  const defaultWhiteTexture = new THREE.Texture(defaultWhiteCanvas);
  defaultWhiteTexture.needsUpdate = true;

  function enterProjectorViewForProjector(p){
    if (!p || !p.camera || !renderer) return;
    const container = document.getElementById('main-viewport');
    const availW = container.clientWidth;
    const availH = container.clientHeight;
    const aspect = p.camera.aspect || (9/16);
    let targetH = availH;
    let targetW = Math.round(targetH * aspect);
    if (targetW > availW){ targetW = availW; targetH = Math.round(targetW / aspect); }
    renderer.setSize(targetW, targetH);
    camera.aspect = targetW / targetH;
    camera.updateProjectionMatrix();
    renderer.domElement.style.margin = 'auto';
    miniLog(`Viewer resized to projector aspect ${aspect.toFixed(3)} (${targetW}x${targetH})`);
  }
  
  function exitProjectorView(){
    if (!renderer) return;
    const container = document.getElementById('main-viewport');
    const defaultW = defaultViewportSize.w || Math.max(1, container.clientWidth);
    const defaultH = defaultViewportSize.h || Math.max(1, container.clientHeight);
    renderer.setSize(defaultW, defaultH);
    camera.aspect = defaultW / defaultH;
    camera.updateProjectionMatrix();
    renderer.domElement.style.margin = '';
    miniLog('Viewer restored to default aspect');
  }

function createProjectionOverlayMaterial(){
    const mat = new THREE.ShaderMaterial({
      uniforms: { 
        uProjMatrix: { value: new THREE.Matrix4() }, 
        uProjTex: { value: contentTexture || defaultWhiteTexture }, 
        uProjStrength: { value: contentTexture ? 1.0 : 0.0 } 
      },
      vertexShader: `
        precision mediump float;
        uniform mat4 uProjMatrix;
        varying vec4 vProjPos;
        void main(){
          vProjPos = uProjMatrix * modelMatrix * vec4(position,1.0);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }`,
      fragmentShader: `
        precision mediump float;
        uniform sampler2D uProjTex;
        uniform float uProjStrength;
        varying vec4 vProjPos;
        void main(){
          if (uProjStrength <= 0.0001) discard;
          vec3 proj = vProjPos.xyz / vProjPos.w;
          vec2 uv = proj.xy * 0.5 + 0.5;
          if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0){
            discard;
          }
          vec4 projColor = texture2D(uProjTex, uv);
          gl_FragColor = vec4(projColor.rgb * uProjStrength, projColor.a * uProjStrength);
        }`,
      transparent: true, 
      depthTest: false, 
      depthWrite: false, 
      side: THREE.DoubleSide, 
      blending: THREE.NormalBlending
    });
    return mat;
  }
  function createProjectionOverlayForMesh(mesh){
    if (!mesh || projectionOverlays.has(mesh)) return projectionOverlays.get(mesh);
    const mat = createProjectionOverlayMaterial();
    const overlay = new THREE.Mesh(mesh.geometry, mat);
    overlay.frustumCulled = false; overlay.renderOrder = 9999;
    mesh.add(overlay);
    projectionOverlays.set(mesh, overlay);
    return overlay;
  }

  function updateProjectionTexOnOverlays(){
    projectionOverlays.forEach(o => {
      if (!o || !o.material || !o.material.uniforms) return;
      o.material.uniforms.uProjTex.value = contentTexture || defaultWhiteTexture;
      o.material.uniforms.uProjStrength.value = contentTexture ? 1.0 : 0.0;
      if (contentTexture instanceof THREE.VideoTexture) contentTexture.needsUpdate = true;
      o.material.needsUpdate = false;
    });
    if (wall && wall.material && wall.material.uniforms){
      wall.material.uniforms.uProjTex.value = contentTexture || defaultWhiteTexture;
      wall.material.uniforms.uProjStrength.value = contentTexture ? 1.0 : 0.0;
      if (contentTexture instanceof THREE.VideoTexture) contentTexture.needsUpdate = true;
      wall.material.needsUpdate = false;
    }
  }

  function applyProjectionToScene(){
    if (!contentTexture) { updateProjectionTexOnOverlays(); return; }
    createProjectionOverlayForMesh(cube);
    primitives.forEach(p => { if (p && p.userData && p.userData.skipOverlay) return; createProjectionOverlayForMesh(p); });
    updateProjectionTexOnOverlays();
  }

  function updateProjectionOverlaysWithProjector(active){
    const list = [cube].concat(primitives);
    if (!active){
      list.forEach(m=>{ const o = projectionOverlays.get(m); if (o && o.material && o.material.uniforms) o.material.uniforms.uProjStrength.value = 0.0; });
      if (wall && wall.material && wall.material.uniforms) wall.material.uniforms.uProjStrength.value = 0.0;
      return;
    }
    const P = new THREE.Matrix4().multiplyMatrices(active.camera.projectionMatrix, active.camera.matrixWorldInverse);
    list.forEach(m=>{ const o = projectionOverlays.get(m); if (o && o.material && o.material.uniforms){ o.material.uniforms.uProjMatrix.value.copy(P); o.material.uniforms.uProjTex.value = contentTexture || defaultWhiteTexture; if (contentTexture instanceof THREE.VideoTexture) contentTexture.needsUpdate = true; o.material.uniforms.uProjStrength.value = contentTexture ? 1.0 : 0.0; } });
    if (wall && wall.material && wall.material.uniforms){ wall.material.uniforms.uProjMatrix.value.copy(P); wall.material.uniforms.uProjTex.value = contentTexture || defaultWhiteTexture; wall.material.uniforms.uProjStrength.value = contentTexture ? 1.0 : 0.0; if (contentTexture instanceof THREE.VideoTexture) contentTexture.needsUpdate = true; }
  }

  const _exportState = { meshMaterials: new Map(), gridVisible:true, axesVisible:true, helperVis:new Map() };
  function prepareSceneForExport(){
    _exportState.gridVisible = gridHelper ? gridHelper.visible : true;
    _exportState.axesVisible = axesHelper ? axesHelper.visible : true;
    if (gridHelper) gridHelper.visible = false;
    if (axesHelper) axesHelper.visible = false;
    projectors.forEach(p => { if (!p.helper) return; Object.keys(p.helper).forEach(k=>{ const o=p.helper[k]; if (!o) return; _exportState.helperVis.set(o.uuid, o.visible); o.visible = false; }); });
    const blackMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
    [cube].concat(primitives).forEach(m => { if (!m) return; _exportState.meshMaterials.set(m.uuid, m.material); m.material = blackMat; });
  }
  
  function restoreSceneAfterExport(){
    if (gridHelper) gridHelper.visible = _exportState.gridVisible;
    if (axesHelper) axesHelper.visible = _exportState.axesVisible;
    projectors.forEach(p => { if (!p.helper) return; Object.keys(p.helper).forEach(k=>{ const o=p.helper[k]; if (!o) return; const prev=_exportState.helperVis.get(o.uuid); if (typeof prev !== 'undefined') o.visible = prev; }); });
    _exportState.helperVis.clear();
    [cube].concat(primitives).forEach(m => { if (!m) return; const prev=_exportState.meshMaterials.get(m.uuid); if (prev){ m.material = prev; _exportState.meshMaterials.delete(m.uuid); } });
    updateProjectionTexOnOverlays();
  }

  function getActiveProjector(){ const use = document.getElementById('useProj') && document.getElementById('useProj').checked; if (!use) return null; return projectors[0] || null; }

  async function renderSceneToPNGBlob(cam, w, h){
    const rt = new THREE.WebGLRenderTarget(w, h, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat });
    renderer.setRenderTarget(rt); renderer.clear(); renderer.render(scene, cam); renderer.setRenderTarget(null);
    const pixels = new Uint8Array(w * h * 4);
    renderer.readRenderTargetPixels(rt, 0, 0, w, h, pixels);
    rt.dispose();
    const out = new Uint8ClampedArray(w * h * 4);
    for (let y = 0; y < h; y++) { const src = y * w * 4; const dst = (h - 1 - y) * w * 4; out.set(pixels.subarray(src, src + w * 4), dst); }
    const canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d'); const imageData = new ImageData(out, w, h); ctx.putImageData(imageData, 0, 0);
    return new Promise(resolve => canvas.toBlob(blob => resolve(blob), 'image/png'));
  }

  async function exportSequenceFromVideo(exportW, exportH, fps){
    if (!contentVideo) throw new Error('No video loaded for sequence export.');
    const video = contentVideo; const duration = video.duration;
    if (!isFinite(duration) || duration <= 0) throw new Error('Video has invalid duration.');
    const frameCount = Math.ceil(duration * fps);
    miniLog(`Sequence export: duration=${duration.toFixed(2)}s fps=${fps} frames=${frameCount}`);
    const zip = new JSZip();
    const prevPaused = video.paused; const prevCurrent = video.currentTime; video.pause();
    const isVideoTexture = contentTexture instanceof THREE.VideoTexture;
    for (let i = 0; i < frameCount; i++){
      const t = Math.min(duration, (i / fps));
      await new Promise(resolve => { const onSeek = () => { video.removeEventListener('seeked', onSeek); resolve(); }; video.addEventListener('seeked', onSeek); try { video.currentTime = t; } catch(e) { video.removeEventListener('seeked', onSeek); resolve(); } });
      if (isVideoTexture) contentTexture.needsUpdate = true;
      await new Promise(r => setTimeout(r, 20));
      const p = projectors[0];
      if (p){ const prevAspect = p.camera.aspect; p.camera.aspect = exportW / exportH; p.camera.updateProjectionMatrix(); const blobProj = await renderSceneToPNGBlob(p.camera, exportW, exportH); zip.file(`proj_frame_${String(i+1).padStart(5,'0')}.png`, blobProj); p.camera.aspect = prevAspect; p.camera.updateProjectionMatrix(); }
      const blobMain = await renderSceneToPNGBlob(camera, exportW, exportH);
      zip.file(`main_frame_${String(i+1).padStart(5,'0')}.png`, blobMain);
      miniLog(`Exported frame ${i+1}/${frameCount}`);
    }
    video.currentTime = prevCurrent; if (!prevPaused) { video.play().catch(()=>{}); }
    const out = await zip.generateAsync({ type: 'blob' });
    saveAs(out, `export_seq_${Date.now()}.zip`);
    miniLog('Sequence export zip downloaded');
  }

  async function startExport(){
    const res = document.getElementById('exportRes').value;
    const exportW = res==='4k'?3840:(res==='1080p'?1920:800);
    const exportH = res==='4k'?2160:(res==='1080p'?1080:1280);
    const fpsInput = parseInt(document.getElementById('exportFps').value || '30', 10) || 30;
    miniLog(`Export requested ${exportW}x${exportH}`);
    prepareSceneForExport();
    try {
      if (contentVideo){ await exportSequenceFromVideo(exportW, exportH, fpsInput); } else {
        const zip = new JSZip(); const p = projectors[0];
        if (p){ const prevAspect = p.camera.aspect; p.camera.aspect = exportW / exportH; p.camera.updateProjectionMatrix(); const blobProj = await renderSceneToPNGBlob(p.camera, exportW, exportH); if (blobProj) zip.file('proj_frame.png', blobProj); p.camera.aspect = prevAspect; p.camera.updateProjectionMatrix(); }
        const blobMain = await renderSceneToPNGBlob(camera, exportW, exportH);
        if (blobMain) zip.file('main_frame.png', blobMain);
        const out = await zip.generateAsync({ type: 'blob' });
        saveAs(out, `export_${Date.now()}.zip`);
        miniLog('Export ZIP downloaded (single frame)');
      }
    } catch (e) { miniLog('Export error: ' + (e && e.message)); console.error(e); } finally { restoreSceneAfterExport(); }
  }

  function createProjector(x=0,y=2.5,z=10,label='Proj_1'){
    const g = new THREE.Group(); g.position.set(x,y,z); scene.add(g);
    const mark = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 8), new THREE.MeshStandardMaterial({ color: 0x0dd6b6, emissive:0x0dd6b6 }));
    mark.position.set(0,0,0); mark.renderOrder = 1000; g.add(mark);
    const pick = new THREE.Mesh(new THREE.BoxGeometry(1.2,1.2,1.6), new THREE.MeshBasicMaterial({ color:0x00ff00, transparent:true, opacity:0.0 }));
    pick.renderOrder = 1001; pick.position.set(0,0,0); g.add(pick);
    const cone = new THREE.Mesh(new THREE.ConeGeometry(0.35,0.9,16), new THREE.MeshStandardMaterial({ color:0x0d9488 }));
    cone.rotation.x = Math.PI; cone.position.set(0,-0.2,-0.5); cone.visible = false; g.add(cone);
    const cam = new THREE.PerspectiveCamera(45, 9/16, 0.5, 500); cam.position.copy(g.position);
    const p = { id:0, label, group:g, camera:cam, rtPreview:null, orientation:'portrait', helper:{ mark, pick, cone } };
    projectors = [p]; interactiveObjects.push(pick); return p;
  }

  function appendObjectListUI(mesh, name){
    const wrapper = document.createElement('div'); wrapper.className='list-item';
    const label = document.createElement('div'); label.textContent = name || mesh.name || 'Object';
    const controls = document.createElement('div');
    const sel = document.createElement('button'); sel.className='btn'; sel.style.marginRight='6px';
    sel.textContent='Select'; sel.onclick = ()=>{ selectObjectMesh(mesh); transformControl.attach(mesh); transformControl.setSpace('local'); updateMetricsUI(); };
    const del = document.createElement('button'); del.className='btn'; del.textContent='Delete'; del.onclick = ()=>{ removePrimitive(mesh); };
    controls.appendChild(sel); controls.appendChild(del); wrapper.appendChild(label); wrapper.appendChild(controls);
    document.getElementById('object-list').appendChild(wrapper); mesh._listItem = wrapper;
  }

  function registerProjectorUI(p){
    const el=document.getElementById('projector-list'); el.innerHTML=''; const wrapper=document.createElement('div'); wrapper.className='list-item';
    const label=document.createElement('div'); label.textContent = p.label || 'Projector';
    const controls=document.createElement('div'); const sel=document.createElement('button'); sel.className='btn'; sel.textContent='Select';
    sel.onclick = ()=>{ selectProjector(p); transformControl.attach(p.group); transformControl.setSpace('local'); updateMetricsUI(); };
    controls.appendChild(sel); wrapper.appendChild(label); wrapper.appendChild(controls); el.appendChild(wrapper); p._listItem = wrapper;
    const orientSel = document.getElementById('projOrient');
    if (orientSel){ orientSel.style.display = ''; orientSel.value = p.orientation || 'portrait'; }
  }

  function setProjectorOrientationUIFromTopBar(){
    const orientSel = document.getElementById('projOrient'); const p = projectors[0];
    if (!orientSel || !p) return; setProjectorOrientation(p, orientSel.value);
  }

  function setProjectorOrientation(p, mode){
    if (!p || !p.camera) return;
    p.orientation = mode; p.camera.aspect = (mode === 'portrait') ? (9/16) : (16/9); p.camera.updateProjectionMatrix();
    try {
      const previewCanvas = document.getElementById('preview1');
      if (previewCanvas && p.rtPreview) {
        const previewCssW = 200; const previewWpx = Math.max(1, Math.floor(previewCssW * dpr));
        const previewHpx = Math.max(1, Math.floor(previewWpx / p.camera.aspect));
        p.rtPreview.setSize(previewWpx, previewHpx); previewCanvas.width = previewWpx; previewCanvas.height = previewHpx;
        previewCanvas.style.width = previewCssW + 'px'; previewCanvas.style.height = Math.round(previewHpx / dpr) + 'px';
      }
    } catch (err) { console.warn('Preview RT resize failed', err); }
    if (selected && selected.type === 'projector' && selected.obj === p) { enterProjectorViewForProjector(p); }
    updateProjectionOverlaysWithProjector(getActiveProjector());
    miniLog(`${p.label || 'projector'} set to ${mode}`);
  }

  function selectObjectMesh(mesh){ selected = { type:'object', obj: mesh }; miniLog('Selected object (mesh)'); updateMetricsUI(); updateSizeInfo(mesh); }
  function selectProjector(p){ selected = { type:'projector', obj: p }; miniLog(`Selected projector ${p.label}`); updateMetricsUI(); if (p) registerProjectorUI(p); }

  function updateMetricsUI(){
    const nameEl=document.getElementById('metric-name'), xEl=document.getElementById('metric-x'), yEl=document.getElementById('metric-y'), zEl=document.getElementById('metric-z');
    const rxEl=document.getElementById('metric-rotx'), ryEl=document.getElementById('metric-roty'), rzEl=document.getElementById('metric-rotz');
    if (!selected){ nameEl.value=''; xEl.value=''; yEl.value=''; zEl.value=''; rxEl.value=''; ryEl.value=''; rzEl.value=''; return; }
    if (selected.type==='object'){
      const m=selected.obj; nameEl.value=m.name||'Object';
      xEl.value=m.position.x.toFixed(3); yEl.value=m.position.y.toFixed(3); zEl.value=m.position.z.toFixed(3);
      const e = new THREE.Euler().setFromQuaternion(m.quaternion || new THREE.Quaternion());
      rxEl.value=THREE.Math.radToDeg(e.x).toFixed(2); ryEl.value=THREE.Math.radToDeg(e.y).toFixed(2); rzEl.value=THREE.Math.radToDeg(e.z).toFixed(2);
    } else if (selected.type==='projector'){
      const p = selected.obj; nameEl.value = p.label || 'Projector';
      xEl.value = p.group.position.x.toFixed(3); yEl.value = p.group.position.y.toFixed(3); zEl.value = p.group.position.z.toFixed(3);
      const e = new THREE.Euler().setFromQuaternion(p.group.quaternion || new THREE.Quaternion());
      rxEl.value=THREE.Math.radToDeg(e.x).toFixed(2); ryEl.value=THREE.Math.radToDeg(e.y).toFixed(2); rzEl.value=THREE.Math.radToDeg(e.z).toFixed(2);
    }
  }
function updateSizeInfo(mesh){
try{
const box=new THREE.Box3().setFromObject(mesh);
const size=new THREE.Vector3();
box.getSize(size);
miniLog(`Size: ${size.x.toFixed(3)} √ó ${size.y.toFixed(3)} √ó ${size.z.toFixed(3)} m`);}catch(e){}
}
function setupMetricKeyboard(){
['metric-x','metric-y','metric-z','metric-rotx','metric-roty','metric-rotz'].forEach(id=>{
const el=document.getElementById(id);
el && el.addEventListener('keydown', e=>{ if (e.key === 'Enter'){ applyMetricsUI(); } });
});
}
function setupTransformControlEvents(){
transformControl.addEventListener('dragging-changed', (e)=> { orbit.enabled = !e.value; });
transformControl.addEventListener('change', ()=> {
updateMetricsUI();
if (selected && selected.type === 'projector' && selected.obj){
const p = selected.obj;
p.camera.position.copy(p.group.position);
p.camera.quaternion.copy(p.group.quaternion);
p.camera.updateProjectionMatrix && p.camera.updateProjectionMatrix();
if (p.rtPreview){
renderer.setRenderTarget(p.rtPreview);
renderer.clear();
renderer.render(scene,p.camera);
renderer.setRenderTarget(null);
drawPreviewFromRT(p.rtPreview, document.getElementById('preview1'));
}
}
renderer.render(scene, camera);
});
transformControl.addEventListener('objectChange', ()=> { if (transformControl.object) { transformControl.updateMatrixWorld(); transformControl.object.updateMatrixWorld(); } });
}
function setTransformMode(mode){
if (!transformControl) return;
transformControl.setMode(mode);
miniLog(`Gizmo mode: ${mode}`);
}
function deleteSelected(){
if (!selected) return alert('Nothing selected');
if (selected.type === 'object') removePrimitive(selected.obj);
else if (selected.type === 'projector') {
const p = selected.obj;
try { p._listItem && p._listItem.remove(); } catch(e){}
Object.values(p.helper||{}).forEach(h=>{ if (h && h.parent) h.parent.remove(h); });
if (p.group && p.group.parent) p.group.parent.remove(p.group);
projectors = projectors.filter(pp=>pp!==p);
selected = null;
updateMetricsUI();
}
}
function animate(){
requestAnimationFrame(animate);
if (contentVideo && !contentVideo.paused && contentVideo.readyState >= 2){
if (contentTexture && contentTexture instanceof THREE.VideoTexture) contentTexture.needsUpdate = true;
cube.rotation.y += 0.005;
}
projectors.forEach(p=>{ if (p.camera && p.group){ p.camera.position.copy(p.group.position); p.camera.quaternion.copy(p.group.quaternion); p.camera.updateMatrixWorld(); } });
const activeProj = projectors[0];
if (wall && wall.material && wall.material.uniforms){
  wall.material.uniforms.uProjTex.value = contentTexture || defaultWhiteTexture;
  if (contentTexture instanceof THREE.VideoTexture) contentTexture.needsUpdate = true;
  if (activeProj && activeProj.camera){
    const P = new THREE.Matrix4().multiplyMatrices(activeProj.camera.projectionMatrix, activeProj.camera.matrixWorldInverse);
    wall.material.uniforms.uProjMatrix.value.copy(P);
    wall.material.uniforms.uProjStrength.value = contentTexture ? 1.0 : 0.0;
  } else {
    wall.material.uniforms.uProjStrength.value = 0.0;
  }
}

renderPreviews();
renderer.render(scene, camera);
}
function drawPreviewFromRT(rt, canvas){
if (!canvas || !rt) return;
const ctx = canvas.getContext('2d'); const w = rt.width, h = rt.height;
const pixels = new Uint8Array(w*h*4);
    try{
      renderer.readRenderTargetPixels(rt,0,0,w,h,pixels);
      const out = new Uint8ClampedArray(w*h*4);
      for(let y=0;y<h;y++){
        const src = y*w*4;
        const dst = (h-1-y)*w*4;
        out.set(pixels.subarray(src,src+w*4), dst);
      }
      const imageData = new ImageData(out, w, h);
      ctx.putImageData(imageData,0,0);
    }catch(e){}
  }

  function renderPreviews(){
    const p = projectors[0];
    const canvas1 = document.getElementById('preview1');
    const canvas2 = document.getElementById('preview2');
    if (!p || !canvas1) return;
    
    // Preview 1: Projector output (what the projector sees)
    if (!p.rtPreview){
      const w = Math.max(1, Math.floor(400 * dpr));
      const h = Math.max(1, Math.floor(300 * dpr));
      p.rtPreview = new THREE.WebGLRenderTarget(w, h, { minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBAFormat });
    }
    const prevPick = p.helper.pick.visible;
    p.helper.pick.visible = false;
    renderer.setRenderTarget(p.rtPreview);
    renderer.clear();
    renderer.render(scene, p.camera);
    renderer.setRenderTarget(null);
    p.helper.pick.visible = prevPick;
    drawPreviewFromRT(p.rtPreview, canvas1);
    
    // Preview 2: Main camera view WITH projection mapping (shows deformation)
    if (canvas2) {
      if (!window.mainPreviewRT) {
        const w = Math.max(1, Math.floor(400 * dpr));
        const h = Math.max(1, Math.floor(300 * dpr));
        window.mainPreviewRT = new THREE.WebGLRenderTarget(w, h, { minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBAFormat });
      }
      // Temporarily hide helpers for clean preview
      const prevGrid = gridHelper ? gridHelper.visible : false;
      const prevAxes = axesHelper ? axesHelper.visible : false;
      if (gridHelper) gridHelper.visible = false;
      if (axesHelper) axesHelper.visible = false;
      projectors.forEach(proj => { 
        if (proj.helper) {
          Object.values(proj.helper).forEach(h => {
            if (h) h.visible = false;
          });
        }
      });
      
      renderer.setRenderTarget(window.mainPreviewRT);
      renderer.clear();
      renderer.render(scene, camera);
      renderer.setRenderTarget(null);
      drawPreviewFromRT(window.mainPreviewRT, canvas2);
      
      // Restore helpers
      if (gridHelper) gridHelper.visible = prevGrid;
      if (axesHelper) axesHelper.visible = prevAxes;
      projectors.forEach(proj => { 
        if (proj.helper) {
          Object.values(proj.helper).forEach(h => {
            if (h) h.visible = true;
          });
        }
      });
    }
    
    updateProjectionOverlaysWithProjector(getActiveProjector());
  }

  async function uploadContent(){
    const input=document.createElement('input'); input.type='file'; input.accept='image/*,video/*';
input.onchange=async(e)=>{ const f=e.target.files[0]; if(!f) return; const url=URL.createObjectURL(f); miniLog('Loaded: '+f.name);
if(f.type.startsWith('video/')){
const v=document.createElement('video');
v.src=url; v.crossOrigin='anonymous'; v.loop=true; v.muted=true; v.playsInline=true;
await v.play().catch(()=>{});
contentVideo = v;
const videoTex = new THREE.VideoTexture(v);
videoTex.minFilter = THREE.LinearFilter; videoTex.magFilter = THREE.LinearFilter; videoTex.format = THREE.RGBAFormat;
videoTex.generateMipmaps = false;
videoTex.needsUpdate = true;
contentTexture = videoTex;
applyProjectionToScene();
miniLog('Video loaded as content texture');
v.addEventListener('ended', ()=> {
if (document.getElementById('autoRec').checked && isRecording) stopRecordingStreams();
});
} else {
const img = new Image();
img.crossOrigin='anonymous';
img.onload = ()=>{
const tex = new THREE.Texture(img);
tex.needsUpdate = true;
tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter;
contentTexture = tex;
applyProjectionToScene();
miniLog('Image loaded as content texture');
};
img.onerror = ()=> miniLog('Image load error');
img.src = url;
}
};
input.click();
}
let isRecording=false,_videoEndedHandler=null; const mediaRecsArr=[], lastRecordedBlobs={proj:null,main:null};
async function startRecordingStreams(){
if(isRecording) return;
prepareSceneForExport();
isRecording=true; document.getElementById('recordBtn').textContent='‚èπÔ∏è Stop';
mediaRecsArr.length=0;
lastRecordedBlobs.proj = null; lastRecordedBlobs.main = null;
try{
const projCanvas = document.getElementById('preview1');
if (projCanvas){
const s = projCanvas.captureStream(30);
const chunks = [];
const mr = new MediaRecorder(s, { mimeType: 'video/webm;codecs=vp8' });
mr.ondataavailable = e=>{ if(e.data && e.data.size) chunks.push(e.data); };
mr.onstop = ()=>{ const blob = new Blob(chunks, { type: 'video/webm' }); lastRecordedBlobs.proj = blob; miniLog('Projector recording finished'); };
mr.start();
mediaRecsArr.push({ rec: mr });
}
if (renderer && renderer.domElement){
const s2 = renderer.domElement.captureStream(30);
const chunks2 = [];
const mr2 = new MediaRecorder(s2, { mimeType: 'video/webm;codecs=vp8' });
mr2.ondataavailable = e=>{ if(e.data && e.data.size) chunks2.push(e.data); };
mr2.onstop = ()=>{ const blob = new Blob(chunks2, { type: 'video/webm' }); lastRecordedBlobs.main = blob; miniLog('Main recording finished'); };
mr2.start();
mediaRecsArr.push({ rec: mr2 });
}
miniLog('Recording started');
}catch(e){ miniLog('Recording error: '+ (e && e.message)); stopRecordingStreams(); }
}
function stopRecordingStreams(){
if(!isRecording) return;
isRecording=false; document.getElementById('recordBtn').textContent='üî¥ Record';
mediaRecsArr.forEach(en=>{ try{ en.rec.stop(); }catch(e){} });
mediaRecsArr.length=0;
restoreSceneAfterExport();
miniLog('Recording stopped');
}
function toggleRecording(){ if(isRecording) stopRecordingStreams(); else startRecordingStreams(); }
function downloadLast(kind){
const b=lastRecordedBlobs[kind];
if(!b) return alert('No recording');
const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download = kind+'_rec.webm'; a.click();
}
let pointerDownInfo=null;
function onPointerDown(e){ pointerDownInfo={x:e.clientX,y:e.clientY,rect:renderer.domElement.getBoundingClientRect()}; }
function onPointerUp(e){
if (!pointerDownInfo) return;
const rect = pointerDownInfo.rect || renderer.domElement.getBoundingClientRect();
const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
const pointer = new THREE.Vector2(x,y);
const ray = new THREE.Raycaster(); ray.setFromCamera(pointer,camera);
const hits = ray.intersectObjects(interactiveObjects, true);
if (hits.length>0){
const hit = hits[0].object;
const proj = projectors.find(p=>{ let cur = hit; while(cur){ if(cur===p.group) return true; cur = cur.parent; } return false; });
if (proj){ selectProjector(proj); setTimeout(()=>{ transformControl.attach(proj.group); transformControl.setSpace('local'); updateMetricsUI(); },0); pointerDownInfo=null; return; }
let mesh = hit; while(mesh && interactiveObjects.indexOf(mesh)===-1) mesh = mesh.parent;
if (mesh){ selectObjectMesh(mesh); setTimeout(()=>{ transformControl.attach(mesh); transformControl.setSpace('local'); updateMetricsUI(); },0); pointerDownInfo=null; return; }
} else {
transformControl.detach(); selected=null; exitProjectorView(); updateMetricsUI();
}
pointerDownInfo=null;
}
function initScene(){
scene = new THREE.Scene(); scene.background = new THREE.Color(0x0a0a0a);
const container = document.getElementById('main-viewport');
camera = new THREE.PerspectiveCamera(50,(container.clientWidth)/(container.clientHeight),0.1,1000); camera.position.set(15,10,15);
renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer:true });
try { if (renderer && renderer.debug) renderer.debug.checkShaderErrors = true; } catch(e) {}
renderer.setSize(container.clientWidth, container.clientHeight); renderer.setPixelRatio(dpr);
defaultViewportSize.w = container.clientWidth;
defaultViewportSize.h = container.clientHeight;
document.getElementById('main-viewport').appendChild(renderer.domElement);
orbit = new THREE.OrbitControls(camera, renderer.domElement); orbit.enableDamping = true;
gridHelper = new THREE.GridHelper(100,100,0x444444,0x222222); scene.add(gridHelper);
axesHelper = new THREE.AxesHelper(5); scene.add(axesHelper);
transformControl = new THREE.TransformControls(camera, renderer.domElement); scene.add(transformControl);
setupTransformControlEvents(); setupMetricKeyboard();
const ambient = new THREE.AmbientLight(0x404040,0.6); scene.add(ambient); const dir = new THREE.DirectionalLight(0xffffff,0.6); dir.position.set(10,20,10); scene.add(dir);
const geom = new THREE.BoxGeometry(4,6,4); const mat = new THREE.MeshStandardMaterial({ color:0x888888 }); cube = new THREE.Mesh(geom,mat); cube.position.set(0,3,0); scene.add(cube); interactiveObjects.push(cube);
try {
  const wallGeom = new THREE.PlaneGeometry(12, 8);
  const wallMat = createProjectionOverlayMaterial();
  wallMat.uniforms.uProjTex.value = contentTexture || defaultWhiteTexture;
  wallMat.uniforms.uProjStrength.value = contentTexture ? 1.0 : 0.0;
  wall = new THREE.Mesh(wallGeom, wallMat);
  wall.position.set(0, 4, -8);
  wall.rotation.y = Math.PI;
  scene.add(wall);
  interactiveObjects.push(wall);
  wall.userData.skipOverlay = true;
  primitives.push(wall);
  appendObjectListUI(wall, 'Wall');
  miniLog('Wall created using projection shader');
} catch (err) { console.warn('Wall creation failed', err); }

const p = createProjector(0,2.5,10,'Proj_1'); p.orientation='portrait'; p.camera.aspect=9/16; p.camera.updateProjectionMatrix();
const cnv = document.getElementById('preview1'); cnv.width = Math.max(1, Math.floor(200*dpr)); cnv.height = Math.max(1, Math.floor(150*dpr));
p.rtPreview = new THREE.WebGLRenderTarget(cnv.width, cnv.height, { minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBAFormat });
registerProjectorUI(p);
const orientSel = document.getElementById('projOrient');
orientSel && orientSel.addEventListener('change', setProjectorOrientationUIFromTopBar);
orientSel && (orientSel.style.display = projectors.length ? '' : 'none');
document.getElementById('addBox').addEventListener('click', ()=> addPrimitive('box'));
document.getElementById('addPlane').addEventListener('click', ()=> addPrimitive('plane'));
document.getElementById('addSphere').addEventListener('click', ()=> addPrimitive('sphere'));
document.getElementById('metric-apply').addEventListener('click', applyMetricsUI);
window.addEventListener('resize', ()=>{ const w = container.clientWidth; const h = container.clientHeight; renderer.setSize(w, h); camera.aspect = w / h; camera.updateProjectionMatrix(); defaultViewportSize.w = w; defaultViewportSize.h = h; });
renderer.domElement.addEventListener('pointerdown', onPointerDown); renderer.domElement.addEventListener('pointerup', onPointerUp);
animate();
miniLog('Scene ready ‚Äì v23 with dual preview (proj output + main view mapping)');
}
function addPrimitive(type){
let mesh;
if (type==='box') mesh = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshStandardMaterial({ color: 0x6b8cff }));
else if (type==='plane') mesh = new THREE.Mesh(new THREE.PlaneGeometry(3,3), new THREE.MeshStandardMaterial({ color: 0x88cc88, side: THREE.DoubleSide }));
else mesh = new THREE.Mesh(new THREE.SphereGeometry(1,24,16), new THREE.MeshStandardMaterial({ color: 0xffb86b }));
mesh.position.set((Math.random()-0.5)*6, 1 + Math.random()*2, (Math.random()-0.5)*6);
scene.add(mesh);
primitives.push(mesh);
interactiveObjects.push(mesh);
appendObjectListUI(mesh, type.charAt(0).toUpperCase() + type.slice(1));
if (contentTexture) createProjectionOverlayForMesh(mesh);
}
window.uploadContent = uploadContent;
window.toggleRecording = toggleRecording;
window.startExport = startExport;
window.downloadLast = downloadLast;
window.setTransformMode = setTransformMode;
window.deleteSelected = deleteSelected;
window.togglePlay = () => {
if (!contentVideo) return alert('Load video');
if (contentVideo.paused) {
contentVideo.play().catch(()=>{});
document.getElementById('btnPlay').textContent='‚è∏Ô∏è Pause';
if (document.getElementById('autoRec').checked) { startRecordingStreams(); }
} else {
contentVideo.pause();
document.getElementById('btnPlay').textContent='‚ñ∂ Play';
if (document.getElementById('autoRec').checked && isRecording) { stopRecordingStreams(); }
}
};
function applyMetricsUI(){
if (!selected) { alert('No selection'); return; }
const x = parseFloat(document.getElementById('metric-x').value || '0');
const y = parseFloat(document.getElementById('metric-y').value || '0');
const z = parseFloat(document.getElementById('metric-z').value || '0');
const rx = THREE.Math.degToRad(parseFloat(document.getElementById('metric-rotx').value || '0'));
const ry = THREE.Math.degToRad(parseFloat(document.getElementById('metric-roty').value || '0'));
const rz = THREE.Math.degToRad(parseFloat(document.getElementById('metric-rotz').value || '0'));
if (selected.type === 'object'){
const m = selected.obj; m.position.set(x,y,z); m.quaternion.setFromEuler(new THREE.Euler(rx,ry,rz,'XYZ')); m.updateMatrixWorld();
} else {
const p = selected.obj; p.group.position.set(x,y,z); p.group.quaternion.setFromEuler(new THREE.Euler(rx,ry,rz,'XYZ')); p.group.updateMatrixWorld();
if (p.camera){ p.camera.position.copy(p.group.position); p.camera.quaternion.copy(p.group.quaternion); p.camera.updateProjectionMatrix && p.camera.updateProjectionMatrix(); }
}
transformControl.update && transformControl.update();
updateMetricsUI();
}
function removePrimitive(mesh){
try{
const overlay = projectionOverlays.get(mesh);
if (overlay){ overlay.parent && overlay.parent.remove(overlay); overlay.material && overlay.material.dispose(); projectionOverlays.delete(mesh); }
scene.remove(mesh);
mesh.geometry && mesh.geometry.dispose && mesh.geometry.dispose();
if (mesh.material) { if (Array.isArray(mesh.material)) mesh.material.forEach(m=>m.dispose && m.dispose()); else mesh.material.dispose && mesh.material.dispose(); }
const idx = primitives.indexOf(mesh); if (idx !== -1) primitives.splice(idx,1);
const ii = interactiveObjects.indexOf(mesh); if (ii !== -1) interactiveObjects.splice(ii,1);
mesh._listItem && mesh._listItem.remove();
transformControl.detach();
selected = null;
updateMetricsUI();
miniLog('Primitive removed');
} catch(e){ console.warn(e); }
}
initScene();
</script>
</body>
</html>
```